---
ID: "5c8b5da2-9d24-4b5b-8900-595806286539"
Parent: "2b339081-5fa3-4b4a-a497-001d727a3c7d"
Template: "dd22f1b3-bd87-4db2-9e7d-f7a496888d43"
Path: "/sitecore/system/Modules/PowerShell/Script Library/X-Demo/Development/SPE-Remoting"
DB: master
SharedFields:
- ID: "b1a94ff0-6897-47c0-9c51-aa6acb80b1f0"
  Hint: Script
  Value: |
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    
    Add-Type @"
    using System.Net;
    using System.Security.Cryptography.X509Certificates;
    
    public class TrustAllCertsPolicy : ICertificatePolicy {
        public bool CheckValidationResult(ServicePoint sp, X509Certificate cert, WebRequest request, int certificateProblem) {
            return true;
        }
    }
    "@
    [System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy
    
    function Get-UsingVariables {
        param ([scriptblock]$ScriptBlock)
        $ScriptBlock.Ast.FindAll({$args[0] -is [System.Management.Automation.Language.UsingExpressionAst]},$true)
    }
    
    function Get-UsingVariableValues {
        param ([System.Management.Automation.Language.UsingExpressionAst[]]$usingVar)
        $usingVar = $usingVar | Group SubExpression | ForEach {$_.Group | Select -First 1}        
        ForEach ($var in $usingVar) {
            try {
                $value = $null
                $isRunspace = ($MyInvocation.CommandOrigin -eq [System.Management.Automation.CommandOrigin]::Runspace -or $MyInvocation.CommandOrigin -eq [System.Management.Automation.CommandOrigin]::Internal)
                $userpath = $Var.SubExpression.VariablePath.UserPath
                if ($isRunspace -and (Test-Path -Path "variable:\$($userpath)")) {
                    Write-Verbose "Checking the Runspace for the variable $($userpath)."
                    $value = Get-Variable -Name $userpath
                }
    
                if($value -eq $null -or [string]::IsNullOrEmpty($value.Value)) {
                    Write-Verbose "Checking the SessionState for the variable $($userpath)."
                    $value = ($PSCmdlet.SessionState.PSVariable.Get($userpath))
                    if ([string]::IsNullOrEmpty($value)) {
                        throw 'No value!'
                    }
                }
                [pscustomobject]@{
                    Name = $var.SubExpression.Extent.Text
                    Value = $value.Value
                    NewName = ('$__using_{0}' -f $var.SubExpression.VariablePath.UserPath)
                    NewVarName = ('__using_{0}' -f $var.SubExpression.VariablePath.UserPath)
                }
            } catch {
                throw "The value of the using variable '$($var.SubExpression.Extent.Text)' cannot be retrieved because it has not been set in the local session."
            }
        }
    }
    
    function New-ScriptSession {
        <#
            .SYNOPSIS
                Creates a new script session in Sitecore PowerShell Extensions via web service calls.
        
            .EXAMPLE
                The following remotely connects to an instance of Sitecore initializes a session.
                
                New-ScriptSession -Username admin -Password b -ConnectionUri http://remotesitecore
        
                Username      : admin
                Password      : b
                ConnectionUri : http://concentrasitecore/
                SessionId     : 528b9865-a69e-4875-919f-12209646c934
                Credential    : 
            
            .PARAMETER Username
                Specifies the Sitecore identity used for connecting to a remote instance.
    
            .PARAMETER Password
                Specifies the Sitecore password associated with the identity. 
            
            .PARAMETER Timeout
                Specifies the duration of the wait, in seconds.
    
            .PARAMETER ConnectionUri
                Specifies the remote instance url. HTTPS is highly recommended.
    
            .PARAMETER Credential
                Specifies a user account that has permission to perform this action. The default is the current user. This is an alternative to using the UseDefaultCredential parameter.
    
            .PARAMETER UseDefaultCredential
                Indicates that this command uses the default credential. This command sets the UseDefaultCredential property in the resulting proxy object to True. This is an alternative to using the Credential parameter.
            
            .LINK
                Invoke-RemoteScript
    
            .LINK
                Wait-RemoteScriptSession
    
            .LINK
                Stop-ScriptSession
    
        #>
        [CmdletBinding(DefaultParameterSetName="All")]
        param(
            [Parameter(Mandatory = $true)]
            [ValidateNotNullOrEmpty()]
            [string]$Username = $null,
    
            [Parameter(Mandatory = $true)]
            [ValidateNotNullOrEmpty()]
            [string]$Password = $null,
    
            [Parameter(Mandatory = $true)]
            [ValidateNotNullOrEmpty()]
            [Uri[]]$ConnectionUri = $null,
    
            [Parameter(Mandatory = $false, HelpMessage = "The timeout in seconds.")]
            [int]$Timeout,
    
            [Parameter(Mandatory = $false, ParameterSetName = "Credential")]
            [System.Management.Automation.PSCredential]
            $Credential,
    
            [Parameter(Mandatory = $false, ParameterSetName = "DefaultCredentials")]
            [switch]$UseDefaultCredentials
        )
        
        begin {
            $sessionId = [guid]::NewGuid()
            $session = @{
                "Username" = [string]$Username
                "Password" = [string]$Password
                "SessionId" = [string]$sessionId
                "Credential" = [System.Management.Automation.PSCredential]$Credential
                "UseDefaultCredentials" = [bool]$UseDefaultCredentials
                "Connection" = @()
                "PersistentSession" = $false
            }
        }
    
        process {
    
            foreach($uri in $ConnectionUri) {
    
                $connection = [PSCustomObject]@{
                    Uri = [Uri]$uri
                    BaseUri = [Uri]$uri
                }
    
                $session["Connection"] += @($connection)
            }
        }
        
        end {
            [PSCustomObject]$session
        }
    }
    
    if (-not ([System.Management.Automation.PSTypeName]'WebClientWithResponse').Type) {
        Add-Type @"
    using System.Net;
    using System.IO;
    
    public class WebClientWithResponse : WebClient
    {
        // we will store the response here. We could store it elsewhere if needed.
        // This presumes the response is not a huge array...
        public byte[] Response { get; private set; }
    
        protected override WebResponse GetWebResponse(WebRequest request)
        {
            var response = base.GetWebResponse(request);
            var httpResponse = response as HttpWebResponse;
            if (httpResponse != null)
            {
                using (var stream = httpResponse.GetResponseStream())
                {
                    using (var ms = new MemoryStream())
                    {
                        stream.CopyTo(ms);
                        Response = ms.ToArray();
                    }
                }
            }
            return response;
        }
        
        protected override WebRequest GetWebRequest(System.Uri address)
        {
            HttpWebRequest request = base.GetWebRequest(address) as HttpWebRequest;
            request.AutomaticDecompression = DecompressionMethods.Deflate | DecompressionMethods.GZip;
            return request;
        }
    }
    "@
    }
    
    function Invoke-RemoteScript {
        <#
            .SYNOPSIS
                Run scripts in Sitecore PowerShell Extensions via web service calls.
    
            .DESCRIPTION
                When using commands such as Write-Verbose, be sure the preference settings are configured properly.
    
                Change each of these to "Continue" in order to see the message appear in the console.
    
                Example values:
    
                ConfirmPreference              High
                DebugPreference                SilentlyContinue
                ErrorActionPreference          Continue
                InformationPreference          SilentlyContinue
                ProgressPreference             Continue
                VerbosePreference              SilentlyContinue
                WarningPreference              Continue
                WhatIfPreference               False
        
            .EXAMPLE
                The following example remotely executes a script in Sitecore using a reusable session.
        
                $session = New-ScriptSession -Username admin -Password b -ConnectionUri http://remotesitecore
                Invoke-RemoteScript -Session $session -ScriptBlock { Get-User -id admin }
                Stop-ScriptSession -Session $session
        
                Name                     Domain       IsAdministrator IsAuthenticated
                ----                     ------       --------------- ---------------
                sitecore\admin           sitecore     True            False
        
            .EXAMPLE
                The following remotely executes a script in Sitecore with the $Using variable.
    
                $date = [datetime]::Now
                $script = {
                    $Using:date
                }
        
                Invoke-RemoteScript -ConnectionUri "http://remotesitecore" -Username "admin" -Password "b" -ScriptBlock $script
                Stop-ScriptSession -Session $session
        
                6/25/2015 11:09:17 AM
                        
            .EXAMPLE
                The following example runs a script as a ScriptSession job on the server (using Start-ScriptSession internally).
                The arguments are passed to the server with the help of the $Using convention.
                The results are finally returned and the job is removed.
                
                $session = New-ScriptSession -Username admin -Password b -ConnectionUri http://remotesitecore
                $identity = "admin"
                $date = [datetime]::Now
                $jobId = Invoke-RemoteScript -Session $session -ScriptBlock {
                    [Sitecore.Security.Accounts.User]$user = Get-User -Identity $using:identity
                    $user.Name
                    $using:date
                } -AsJob
                Start-Sleep -Seconds 2
    
                Invoke-RemoteScript -Session $session -ScriptBlock {
                    $ss = Get-ScriptSession -Id $using:JobId
                    $ss | Receive-ScriptSession
    
                    if($ss.LastErrors) {
                        $ss.LastErrors
                    }
                }
                Stop-ScriptSession -Session $session
            
            .EXAMPLE
                The following remotely executes a script in Sitecore with arguments.
                
                $script = {
                    [Sitecore.Security.Accounts.User]$user = Get-User -Identity admin
                    $user
                    $params.date.ToString()
                }
        
                $args = @{
                    "date" = [datetime]::Now
                }
        
                Invoke-RemoteScript -ConnectionUri "http://remotesitecore" -Username "admin" -Password "b" -ScriptBlock $script -ArgumentList $args
                Stop-ScriptSession -Session $session
        
                Name                     Domain       IsAdministrator IsAuthenticated
                ----                     ------       --------------- ---------------
                sitecore\admin           sitecore     True            False          
                6/25/2015 11:09:17 AM
        
        	.LINK
        		Wait-RemoteScriptSession
    
        	.LINK
        		New-ScriptSession
    
        	.LINK
        	    Stop-ScriptSession
        #>
       [CmdletBinding(SupportsShouldProcess = $true, DefaultParameterSetName="InProcess")]
        param(
            
            [Parameter(ParameterSetName='InProcess')]
            [Parameter(ParameterSetName='Session')]
            [Parameter(ParameterSetName='Uri')]
            [scriptblock]$ScriptBlock,
    
            [Parameter(ParameterSetName='Session')]
            [ValidateNotNull()]
            [pscustomobject]$Session,
    
            [Parameter(ParameterSetName='Uri')]
            [Uri[]]$ConnectionUri,
    
            [Parameter(ParameterSetName='Uri')]
            [string]$SessionId,
    
            [Parameter(ParameterSetName='Uri')]
            [string]$Username,
    
            [Parameter(ParameterSetName='Uri')]
            [string]$Password,
    
            [Parameter(ParameterSetName='Uri')]
            [System.Management.Automation.PSCredential]
            $Credential,
            
            [Parameter()]
            [Alias("ArgumentList")]
            [hashtable]$Arguments,
    
            [Parameter(ParameterSetName='Session')]
            [switch]$AsJob,
            
            [Parameter()]
            [switch]$Raw
        )
    
        if($PSCmdlet.MyInvocation.BoundParameters["WhatIf"].IsPresent) {
            $functionScriptBlock = {
                $WhatIfPreference = $true
            }
            $ScriptBlock = [scriptblock]::Create($functionScriptBlock.ToString() + $ScriptBlock.ToString());
        }
        $hasRedirectedMessages = $false
        if($PSCmdlet.MyInvocation.BoundParameters["Debug"].IsPresent -or $PSCmdlet.MyInvocation.BoundParameters["Verbose"].IsPresent) {
            $hasRedirectedMessages = $true
            $functionScriptBlock = {
                if($PSVersionTable.PSVersion.Major -ge 5) {
                    function Write-Information {
                        param([string]$Message)
                        $InformationPreference = "Continue"
                        Microsoft.PowerShell.Utility\Write-Information -Message $Message 6>&1
                    }
                }
                function Write-Debug {
                    param([string]$Message)
                    $DebugPreference = "Continue"
                    Microsoft.PowerShell.Utility\Write-Debug -Message $Message 5>&1
                }
                function Write-Verbose {
                    param([string]$Message)
                    $VerbosePreference = "Continue"
                    Microsoft.PowerShell.Utility\Write-Verbose -Message $Message 4>&1
                }
                function Write-Warning {
                    param([string]$Message)
                    $WarningPreference = "Continue"
                    Microsoft.PowerShell.Utility\Write-Warning -Message $Message 3>&1
                }
                function Write-Error {
                    param([string]$Message)
                    $WarningPreference = "Continue"
                    Microsoft.PowerShell.Utility\Write-Error -Message $Message 2>&1
                }
            }
            $ScriptBlock = [scriptblock]::Create($functionScriptBlock.ToString() + $ScriptBlock.ToString());
        }
    
        if($AsJob.IsPresent) {
            $nestedScript = $ScriptBlock.ToString()
            $ScriptBlock = [scriptblock]::Create("Start-ScriptSession -ScriptBlock { $($nestedScript) } -ArgumentList `$params | Select-Object -ExpandProperty ID")
        }
    
        $usingVariables = @(Get-UsingVariables -ScriptBlock $scriptBlock | 
            Group-Object -Property SubExpression | 
            ForEach {
            $_.Group | Select -First 1
        })
        
        $invokeWithArguments = $false        
        if ($usingVariables.count -gt 0) {
            $usingVar = $usingVariables | Group-Object -Property SubExpression | ForEach {$_.Group | Select -First 1}  
            Write-Debug "CommandOrigin: $($MyInvocation.CommandOrigin)"      
            $usingVariableValues = Get-UsingVariableValues -UsingVar $usingVar
            $invokeWithArguments = $true
        }
    
        if ($invokeWithArguments) {
            if(!$Arguments) { $Arguments = @{} }
    
            $paramsPrefix = "`$params."
            if($AsJob.IsPresent) {
                $paramsPrefix = "$"
            }
            $command = $ScriptBlock.ToString()
            foreach($usingVarValue in $usingVariableValues) {
                $Arguments[($usingVarValue.NewName.TrimStart('$'))] = $usingVarValue.Value
                $command = $command.Replace($usingVarValue.Name, "$($paramsPrefix)$($usingVarValue.NewName.TrimStart('$'))")
            }
    
            $newScriptBlock = $command
        } else {
            $newScriptBlock = $scriptBlock.ToString()
        }
    
    
        if($Arguments) {
            #This is still needed in order to pass types
            $parameters = ConvertTo-CliXml -InputObject $Arguments
        }
    
        if($PSCmdlet.ParameterSetName -eq "InProcess") {
            # TODO: This will likely fail for params.
            [scriptblock]::Create($newScriptBlock).Invoke()
        } else {
            if($PSCmdlet.ParameterSetName -eq "Session") {
                $Username = $Session.Username
                $Password = $Session.Password
                $SessionId = $Session.SessionId
                $Credential = $Session.Credential
                $UseDefaultCredentials = $Session.UseDefaultCredentials
                $ConnectionUri = $Session | ForEach-Object { $_.Connection.BaseUri }
                $PersistentSession = $Session.PersistentSession
            } else {
                $SessionId = [guid]::NewGuid()
                $PersistentSession = $false
            }
            
            $serviceUrl = "/-/script/script/?"
            $serviceUrl += "user=" + $Username + "&password=" + $Password + "&sessionId=" + $SessionId + "&rawOutput=" + $Raw.IsPresent + "&persistentSession=" + $PersistentSession
            foreach($uri in $ConnectionUri) {
                $url = $uri.AbsoluteUri.TrimEnd("/") + $serviceUrl
                $localParams = $parameters | Out-String
                
                #creating a psuedo file split on a special comment rather than trying to pass a potentially enormous set of data to the handler
                #theoretically this is the equivalent of a binary upload to the endpoint and breaking it into 2 files
                $Body = "$($newScriptBlock)<#$($SessionId)#>$($localParams)"
                
                Write-Verbose -Message "Preparing to invoke the script against the service at url $($url)"
                $webclient = New-Object WebClientWithResponse
                
                if ($Credential) {
                    $webclient.Credentials = $Credential
                }
    
                if($UseDefaultCredentials) {
                    $webclient.UseDefaultCredentials = $UseDefaultCredentials
                }
    
                $response = & {
                    try {
                        Write-Verbose -Message "Transferring script to server"
                        [System.Net.HttpWebResponse]$script:errorResponse = $null;
                        New-UsingBlock($memorystream = [IO.MemoryStream]::new([Text.Encoding]::UTF8.GetBytes($body))) {
                            $bytes = New-Object byte[] 1024
                            $totalBytesToRead = $memorystream.Length
                            $bytesRead = 0
                            $bytesToRead = $bytes.Length
                            if ($totalBytesToRead - $bytesToRead -lt $bytes.Length) {
                                $bytesToRead = $totalBytesToRead - $bytesRead
                            }
                            $bytes = New-Object byte[] $bytesToRead
    
                            New-UsingBlock($webStream = $webclient.OpenWrite($url)) {
                                while (($bytesToRead = $memorystream.Read($bytes, 0, $bytes.Length)) -gt 0) {
                                    $webStream.Write($bytes, 0, $bytes.Length)
                                    $bytesRead += $bytes.Length
                                    if ($totalBytesToRead - $bytesRead -lt $bytes.Length) {
                                        $bytesToRead = $totalBytesToRead - $bytesRead
                                    }
                                    $bytes = New-Object byte[] $bytesToRead
                                }                                             
                            }
                            $webclient.Response
                            Write-Verbose -Message "Script transfer complete."
                        }
                    }
                    catch [System.Net.WebException] {
                        $webex = $_.Exception
                        if($webex.InnerException) {
                            $script:ex = $webex.InnerException
                            [System.Net.HttpWebResponse]$script:errorResponse = $webex.InnerException.Response
                            if($errorResponse) {
                                if ($errorResponse.StatusCode -eq [System.Net.HttpStatusCode]::Forbidden) {
                                    Write-Verbose -Message "Check that the proper credentials are provided and that the service configurations are enabled."
                                } elseif ($errorResponse.StatusCode -eq [System.Net.HttpStatusCode]::NotFound) {
                                    Write-Verbose -Message "Check that the service files are properly configured."
                                }
                            } else {
                                Write-Verbose -Message $webex.InnerException.Message
                            }
                        }
                    }
                }
                
                if ($errorResponse) {
                    Write-Error -Message "Server response: $($errorResponse.StatusDescription)" -Category ConnectionError `
                        -CategoryActivity "Download" -CategoryTargetName $uri -Exception ($script:ex) -CategoryReason "$($errorResponse.StatusCode)" -CategoryTargetType $RootPath 
                }
                
                if($response) {
                    $trash, $response = $response
                    $parsedResponse = [Text.Encoding]::UTF8.GetString($response)
                    $responseMessages = ""
                    if($Raw) {
                        if($parsedResponse.Contains("<#messages#>")) {
                            $parsedResponse = $parsedResponse -split "<#messages#>"
                        }
                        if($parsedResponse -is [string[]]) {
                            $parsedResponse[0]
                            if($parsedResponse.Length -gt 1) {
                                $responseMessages = $parsedResponse[1]
                                $hasRedirectedMessages = $true
                            }
                        } elseif(![string]::IsNullOrEmpty($parsedResponse)) {
                            $parsedResponse
                        }
                    } elseif($parsedResponse) {
                        $responseMessages = $parsedResponse
                    }
    
                    if(![string]::IsNullOrEmpty($responseMessages)) {
                        if($hasRedirectedMessages) {
                            foreach($record in ConvertFrom-CliXml -InputObject $responseMessages) {
                                if($record -is [PSObject] -and $record.PSObject.TypeNames -contains "Deserialized.System.Management.Automation.VerboseRecord") {
                                    Write-Verbose $record.ToString()
                                } elseif($record -is [PSObject] -and $record.PSObject.TypeNames -contains "Deserialized.System.Management.Automation.InformationRecord") {
                                    Write-Information $record.ToString()
                                } elseif($record -is [PSObject] -and $record.PSObject.TypeNames -contains "Deserialized.System.Management.Automation.DebugRecord") {
                                    Write-Debug $record.ToString()
                                } elseif($record -is [PSObject] -and $record.PSObject.TypeNames -contains "Deserialized.System.Management.Automation.WarningRecord") {
                                    Write-Warning $record.ToString()
                                } elseif($record -is [PSObject] -and $record.PSObject.TypeNames -contains "Deserialized.System.Management.Automation.ErrorRecord") {
                                    Write-Error $record.ToString()
                                } else {
                                    $record
                                }
                            }
                        } else {                        
                            ConvertFrom-CliXml -InputObject $responseMessages
                        }
                    }
                } elseif ($response -eq "login failed") {
                    Write-Verbose "Login with the specified account failed."
                    break            
                } else {
                    Write-Verbose "No response returned by the service. If results were expected confirm that the service is enabled and the account has access."
                }
            }
        }
    }
    
    $watch = [System.Diagnostics.StopWatch]::StartNew()
    $session = New-ScriptSession -Username "admin" -Password "b" -ConnectionUri "https://sc826.dev.local"
    
    $scriptSingleRequest = {
        $parentItem = Get-Item -Path "master:" -ID "{37D08F47-7113-4AD6-A5EB-0C0B04EF6D05}"
        $childItems = $parentItem.Axes.GetDescendants()
    
        $builder = New-Object System.Text.StringBuilder
        $parentYaml = $parentItem | ConvertTo-RainbowYaml
        $builder.AppendLine($parentYaml) > $null
        foreach($childItem in $childItems) {
            $childYaml = $childItem | ConvertTo-RainbowYaml
            $builder.AppendLine($childYaml) > $null
        }
    
        $builder.ToString()
    }
    
    $yaml = Invoke-RemoteScript -ScriptBlock $scriptSingleRequest -Session $session -Raw
    
    $sd = New-Object Sitecore.SecurityModel.SecurityDisabler
    $ed = New-Object Sitecore.Data.Events.EventDisabler
    $buc = New-Object Sitecore.Data.BulkUpdateContext
    
    $rainbowItems = [regex]::Split($yaml, "(?=---)", [System.Text.RegularExpressions.RegexOptions]::Compiled) | 
            Where-Object { ![string]::IsNullOrEmpty($_) } | ConvertFrom-RainbowYaml
    
    foreach($rainbowItem in $rainbowItems) {
        Import-RainbowItem -Item $rainbowItem
    }
    
    
    $buc.Dispose() > $null
    $ed.Dispose() > $null
    $sd.Dispose() > $null
    
    $watch.Stop()
    $totalSeconds = $watch.ElapsedMilliseconds / 1000
    Write-Host "Completed in $($totalSeconds) seconds"
Languages:
- Language: en
  Versions:
  - Version: 1
    Fields:
    - ID: "25bed78c-4957-4165-998a-ca1b52f67497"
      Hint: __Created
      Value: 20181122T030309Z
    - ID: "5dd74568-4d4b-44c1-b513-0af5f4cda34f"
      Hint: __Created by
      Value: |
        sitecore\Admin
